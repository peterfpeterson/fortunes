Rule 1. You can't tell where a program is going to spend its time. Bottlenecks
occur in surprising places, so don't try to second guess and put in a speed
hack until you've proven that's where the bottleneck is.
     - Rob Pike
%
Rule 2. Measure. Don't tune for speed until you've measured, and even then
don't unless one part of the code overwhelms the rest.
     - Rob Pike
%
Rule 3. Fancy algorithms are slow when n is small, and n is usually small.
Fancy algorithms have big constants. Until you know that n is frequently
going to be big, don't get fancy. (Even if n does get big, use Rule 2 first.)
     - Rob Pike
%
Rule 4. Fancy algorithms are buggier than simple ones, and they're much harder
to implement. Use simple algorithms as well as simple data structures.
     - Rob Pike
%
Rule 5. Data dominates. If you've chosen the right data structures and
organized things well, the algorithms will almost always be self-evident.
Data structures, not algorithms, are central to programming.
     - Rob Pike
%
Premature optimization is the root of all evil.
     - Tony Hoare
%
When in doubt, use brute force.
     - Ken Thompson
%
Care About Your Craft
Why spend your life developing software unless you care about doing it well?
%
Provide Options, Don’t Make Lame Excuses
Instead of excuses, provide options. Don’t say it can’t be done; explain what
can be done. - The Pragmatic Programmer
%
Be a Catalyst for Change
You can’t force change on people. Instead, show them how the future might be
and help them participate in creating it. - The Pragmatic Programmer
%
Make Quality a Requirements Issue
Involve your users in determining the project’s real quality requirements.
  - The Pragmatic Programmer
%
Critically Analyze What You Read and Hear
Don’t be swayed by vendors, media hype, or dogma. Analyze information in terms
of you and your project. - The Pragmatic Programmer
%
DRY—Don’t Repeat Yourself
Every piece of knowledge must have a single, unambiguous, authoritative
representation within a system. - The Pragmatic Programmer
%
Eliminate Effects Between Unrelated Things
Design components that are self-contained, independent, and have a single,
well-defined purpose. - The Pragmatic Programmer
%
Use Tracer Bullets to Find the Target
Tracer bullets let you home in on your target by trying things and seeing how
close they land. - The Pragmatic Programmer
%
Program Close to the Problem Domain
Design and code in your user’s language. - The Pragmatic Programmer
%
Iterate the Schedule with the Code
Use experience you gain as you implement to refine the project time scales.
  - The Pragmatic Programmer
%
Use the Power of Command Shells
Use the shell when graphical user interfaces don’t cut it.
  - The Pragmatic Programmer
%
Always Use Source Code Control
Source code control is a time machine for your work—you can go back.
  - The Pragmatic Programmer
%
Don’t Panic When Debugging
Take a deep breath and THINK! about what could be causing the bug.
  - The Pragmatic Programmer
%
Don’t Assume It—Prove It
Prove your assumptions in the actual environment—with real data and boundary
conditions. - The Pragmatic Programmer
%
Write Code That Writes Code
Code generators increase your productivity and help avoid duplication.
  - The Pragmatic Programmer
%
Design with Contracts
Use contracts to document and verify that code does no more and no less than
it claims to do. - The Pragmatic Programmer
%
Use Assertions to Prevent the Impossible
Assertions validate your assumptions. Use them to protect your code from an
uncertain world. - The Pragmatic Programmer
%
Finish What You Start
Where possible, the routine or object that allocates a resource should be
responsible for deallocating it. - The Pragmatic Programmer
%
Configure, Don’t Integrate
Implement technology choices for an application as configuration options, not
through integration or engineering. - The Pragmatic Programmer
%
Analyze Workflow to Improve Concurrency
Exploit concurrency in your user’s workflow. - The Pragmatic Programmer
%
Always Design for Concurrency
Allow for concurrency, and you’ll design cleaner interfaces with fewer
assumptions. - The Pragmatic Programmer
%
Use Blackboards to Coordinate Workflow
Use blackboards to coordinate disparate facts and agents, while maintaining
independence and isolation among participants. - The Pragmatic Programmer
%
Estimate the Order of Your Algorithms
Get a feel for how long things are likely to take before you write code.
  - The Pragmatic Programmer
%
Refactor Early, Refactor Often
Just as you might weed and rearrange a garden, rewrite, rework, and
re-architect code when it needs it. Fix the root of the problem.
  - The Pragmatic Programmer
%
Test Your Software, or Your Users Will
Test ruthlessly. Don’t make your users find bugs for you.
  - The Pragmatic Programmer
%
Don’t Gather Requirements—Dig for Them
Requirements rarely lie on the surface. They’re buried deep beneath layers of
assumptions, misconceptions, and politics. - The Pragmatic Programmer
%
Abstractions Live Longer than Details
Invest in the abstraction, not the implementation. Abstractions can survive the
barrage of changes from different implementations and new technologies.
  - The Pragmatic Programmer
%
Don’t Think Outside the Box—Find the Box
When faced with an impossible problem, identify the real constraints. Ask
yourself: “Does it have to be done this way? Does it have to be done at all?”
  - The Pragmatic Programmer
%
Some Things Are Better Done than Described
Don’t fall into the specification spiral—at some point you need to start
coding. - The Pragmatic Programmer
%
Costly Tools Don’t Produce Better Designs
Beware of vendor hype, industry dogma, and the aura of the price tag. Judge
tools on their merits. - The Pragmatic Programmer
%
Don’t Use Manual Procedures
A shell script or batch file will execute the same instructions, in the same
order, time after time. - The Pragmatic Programmer
%
Coding Ain’t Done ‘Til All the Tests Run
‘Nuff said. - The Pragmatic Programmer
%
Test State Coverage, Not Code Coverage
Identify and test significant program states. Just testing lines of code isn’t
enough. - The Pragmatic Programmer
%
English is Just a Programming Language
Write documents as you would write code: honor the DRY principle, use metadata,
MVC, automatic generation, and so on. - The Pragmatic Programmer
%
Gently Exceed Your Users’ Expectations
Come to understand your users’ expectations, then deliver just that little bit
more. - The Pragmatic Programmer
%
Think! About Your Work
Turn off the autopilot and take control. Constantly critique and appraise your
work. - The Pragmatic Programmer
%
Don’t Live with Broken Windows
Fix bad designs, wrong decisions, and poor code when you see them.
  - The Pragmatic Programmer
%
Remember the Big Picture
Don’t get so engrossed in the details that you forget to check what’s
happening around you. - The Pragmatic Programmer
%
Invest Regularly in Your Knowledge Portfolio
Make learning a habit. - The Pragmatic Programmer
%
It’s Both What You Say and the Way You Say It
There’s no point in having great ideas if you don’t communicate them
effectively. - The Pragmatic Programmer
%
Make It Easy to Reuse
If it’s easy to reuse, people will. Create an environment that supports reuse.
  - The Pragmatic Programmer
%
There Are No Final Decisions
No decision is cast in stone. Instead, consider each as being written in the
sand at the beach, and plan for change. - The Pragmatic Programmer
%
Prototype to Learn
Prototyping is a learning experience. Its value lies not in the code you
produce, but in the lessons you learn. - The Pragmatic Programmer
%
Estimate to Avoid Surprises
Estimate before you start. You’ll spot potential problems up front.
  - The Pragmatic Programmer
%
Keep Knowledge in Plain Text
Plain text won’t become obsolete. It helps leverage your work and simplifies
debugging and testing. - The Pragmatic Programmer
%
Use a Single Editor Well
The editor should be an extension of your hand; make sure your editor is
configurable, extensible, and programmable. - The Pragmatic Programmer
%
Fix the Problem, Not the Blame
It doesn’t really matter whether the bug is your fault or someone else’s—it is
still your problem, and it still needs to be fixed. - The Pragmatic Programmer
%
“select” Isn’t Broken
It is rare to find a bug in the OS or the compiler, or even a third-party
product or library. The bug is most likely in the application.
  - The Pragmatic Programmer
%
Learn a Text Manipulation Language
You spend a large part of each day working with text. Why not have the
computer do some of it for you? - The Pragmatic Programmer
%
You Can’t Write Perfect Software
Software can’t be perfect. Protect your code and users from the inevitable
errors. - The Pragmatic Programmer
%
Crash Early
A dead program normally does a lot less damage than a crippled one.
  - The Pragmatic Programmer
%
Use Exceptions for Exceptional Problems
Exceptions can suffer from all the readability and maintainability problems of
classic spaghetti code. Reserve exceptions for exceptional things.
  - The Pragmatic Programmer
%
Minimize Coupling Between Modules
Avoid coupling by writing “shy” code and applying the Law of Demeter.
  - The Pragmatic Programmer
%
Put Abstractions in Code, Details in Metadata
Program for the general case, and put the specifics outside the compiled code
base. - The Pragmatic Programmer
%
Design Using Services
Design in terms of services—independent, concurrent objects behind
well-defined, consistent interfaces. - The Pragmatic Programmer
%
Separate Views from Models
Gain flexibility at low cost by designing your application in terms of models
and views. - The Pragmatic Programmer
%
Don’t Program by Coincidence
Rely only on reliable things. Beware of accidental complexity, and don’t
confuse a happy coincidence with a purposeful plan.
  - The Pragmatic Programmer
%
Test Your Estimates
Mathematical analysis of algorithms doesn’t tell you everything. Try timing
your code in its target environment. - The Pragmatic Programmer
%
Design to Test
Start thinking about testing before you write a line of code.
  - The Pragmatic Programmer
%
Don’t Use Wizard Code You Don’t Understand
Wizards can generate reams of code. Make sure you understand all of it before
you incorporate it into your project. - The Pragmatic Programmer
%
Work with a User to Think Like a User
It’s the best way to gain insight into how the system will really be used.
  - The Pragmatic Programmer
%
Use a Project Glossary
Create and maintain a single source of all the specific terms and vocabulary
for a project. - The Pragmatic Programmer
%
Start When You’re Ready
You’ve been building experience all your life. Don’t ignore niggling doubts.
  - The Pragmatic Programmer
%
Don’t Be a Slave to Formal Methods
Don’t blindly adopt any technique without putting it into the context of your
development practices and capabilities. - The Pragmatic Programmer
%
Organize Teams Around Functionality
Don’t separate designers from coders, testers from data modelers. Build teams
the way you build code. - The Pragmatic Programmer
%
Test Early. Test Often. Test Automatically.
Tests that run with every build are much more effective than test plans that
sit on a shelf. - The Pragmatic Programmer
%
Use Saboteurs to Test Your Testing
Introduce bugs on purpose in a separate copy of the source to verify that
testing will catch them. - The Pragmatic Programmer
%
Find Bugs Once
Once a human tester finds a bug, it should be the last time a human tester
finds that bug. Automatic tests should check for it from then on.
  - The Pragmatic Programmer
%
Build Documentation In, Don’t Bolt It On
Documentation created separately from code is less likely to be correct and
up to date. - The Pragmatic Programmer
%
Sign Your Work
Craftsmen of an earlier age were proud to sign their work. You should be, too.
  - The Pragmatic Programmer
%
“Whenever faced with a problem, some people say `Lets use AWK.'
  Now, they have two problems.” -- D. Tilbrook
%
You are trying to shoehorn your existing preconceptions of how one
should program onto a vastly different (and older, and more internally
consistent) model.  I suggest your time would be better spent learning
and understanding that other model, and learn to use it properly, and
learn what it can and cannot do, rather than infecting it with this new
cancer out of ignorance.

The notion that everything is a stream of bytes is utterly braindead.
The notion that regexps are the solution to all problems is equally
braindead.

Just like Perl.

Some people, when confronted with a problem, think “I know,
I'll use regular expressions.”  Now they have two problems.

  - Jamie Zawinski
%
> What's wrong with perl?

It combines all the worst aspects of C and Lisp: a billion different
sublanguages in one monolithic executable.  It combines the power of
C with the readability of PostScript.

  - Jamie Zawinski
%
